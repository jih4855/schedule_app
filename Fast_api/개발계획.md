# 공유 일정 기능 개발 계획서

> **작성일:** 2025-10-19
> **목표:** 채팅방 컨셉의 공유 일정 + 공지 기능 추가

---

## 📋 목차

1. [기능 개요](#기능-개요)
2. [DB 스키마 설계](#db-스키마-설계)
3. [API 설계](#api-설계)
4. [프론트엔드 컴포넌트](#프론트엔드-컴포넌트)
5. [권한 설계](#권한-설계)
6. [구현 난이도 및 일정](#구현-난이도-및-일정)
7. [구현 순서](#구현-순서)

---

## 기능 개요

### 핵심 아이디어
- **개인 일정**: 기존 `/schedules` API 그대로 유지
- **공유 일정**: 새로운 "룸(Room)" 컨셉 도입
  - 룸 = 채팅방처럼 동작하는 공유 일정 공간
  - 룸별로 일정 및 공지 관리
- **자연어 파서 재활용**: 기존 `parse_natural_language_to_schedules()` 그대로 사용

### 주요 기능
1. **룸 관리**
   - 룸 생성 (방 만들기)
   - 멤버 초대 (이메일 기반)
   - 멤버 목록 조회

2. **룸 일정**
   - 자연어로 일정 등록 (파서 재활용)
   - 룸 내 모든 일정 조회
   - 일정 수정/삭제 (생성자만)

3. **룸 공지**
   - 공지 작성 (모든 멤버 가능)
   - 공지 목록 조회
   - 공지 고정/해제 (owner/admin만)

---

## DB 스키마 설계

### 1. Room (룸 정보)

```python
# Fast_api/models/room.py (신규)

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from Fast_api.db.base_class import Base
from datetime import datetime
from zoneinfo import ZoneInfo

KST = ZoneInfo('Asia/Seoul')

class Room(Base):
    __tablename__ = "rooms"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)  # "개발팀 일정", "친구들 약속"
    description = Column(String, nullable=True)
    created_by = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=lambda: datetime.now(KST))
    updated_at = Column(DateTime, default=lambda: datetime.now(KST), onupdate=lambda: datetime.now(KST))
```

### 2. RoomMember (룸 참여자)

```python
# Fast_api/models/room.py (계속)

class RoomMember(Base):
    __tablename__ = "room_members"

    id = Column(Integer, primary_key=True, index=True)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    role = Column(String, default="member")  # "owner", "admin", "member"
    joined_at = Column(DateTime, default=lambda: datetime.now(KST))

    # 중복 가입 방지
    __table_args__ = (
        UniqueConstraint('room_id', 'user_id', name='uix_room_user'),
    )
```

### 3. Schedule (기존 모델 수정)

```python
# Fast_api/models/schedule.py (수정)

class Schedule(Base):
    __tablename__ = "schedules"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(String, nullable=True)
    scheduled_at = Column(DateTime, nullable=False)
    is_completed = Column(Boolean, default=False)
    user_id = Column(Integer, ForeignKey("users.id"))  # 생성자

    # 신규 추가
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=True)
    # room_id가 NULL = 개인 일정
    # room_id가 있음 = 공유 일정

    created_at = Column(DateTime, default=lambda: datetime.now(KST))
    updated_at = Column(DateTime, default=lambda: datetime.now(KST), onupdate=lambda: datetime.now(KST))
```

### 4. Notice (공지사항)

```python
# Fast_api/models/notice.py (신규)

from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from Fast_api.db.base_class import Base
from datetime import datetime
from zoneinfo import ZoneInfo

KST = ZoneInfo('Asia/Seoul')

class Notice(Base):
    __tablename__ = "notices"

    id = Column(Integer, primary_key=True, index=True)
    room_id = Column(Integer, ForeignKey("rooms.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)  # 작성자
    title = Column(String, nullable=False)
    content = Column(Text, nullable=False)
    is_pinned = Column(Boolean, default=False)  # 상단 고정 여부
    created_at = Column(DateTime, default=lambda: datetime.now(KST))
    updated_at = Column(DateTime, default=lambda: datetime.now(KST), onupdate=lambda: datetime.now(KST))
```

---

## API 설계

### 1. 룸 관리 API

**파일 위치:** `Fast_api/api/room.py` (신규)

#### 1-1. 룸 생성

```python
POST /api/rooms

Request:
{
  "name": "개발팀 일정",
  "description": "주간 회의 및 일정 공유"
}

Response:
{
  "id": 1,
  "name": "개발팀 일정",
  "description": "주간 회의 및 일정 공유",
  "created_by": 1,
  "created_at": "2025-10-19T10:00:00"
}
```

**구현 코드:**

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from Fast_api.db.session import get_db
from Fast_api.auth.jwt_handle import get_current_user
from Fast_api.models.user import User
from Fast_api.models.room import Room, RoomMember

router = APIRouter()

@router.post("/rooms")
def create_room(
    name: str,
    description: str = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """새 공유 일정 방 생성"""
    room = Room(
        name=name,
        description=description,
        created_by=current_user.id
    )
    db.add(room)
    db.flush()

    # 생성자를 owner로 자동 추가
    member = RoomMember(
        room_id=room.id,
        user_id=current_user.id,
        role="owner"
    )
    db.add(member)
    db.commit()
    db.refresh(room)

    return room
```

#### 1-2. 내가 속한 룸 목록

```python
GET /api/rooms

Response:
[
  {
    "id": 1,
    "name": "개발팀 일정",
    "description": "주간 회의 및 일정 공유",
    "created_by": 1,
    "member_count": 5,
    "my_role": "owner"
  }
]
```

**구현 코드:**

```python
@router.get("/rooms")
def get_my_rooms(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """내가 참여 중인 모든 룸"""
    rooms = db.query(Room).join(RoomMember).filter(
        RoomMember.user_id == current_user.id
    ).all()

    # 각 룸에 멤버 수와 내 역할 추가
    result = []
    for room in rooms:
        member_count = db.query(RoomMember).filter(
            RoomMember.room_id == room.id
        ).count()

        my_role = db.query(RoomMember).filter(
            RoomMember.room_id == room.id,
            RoomMember.user_id == current_user.id
        ).first().role

        result.append({
            **room.__dict__,
            "member_count": member_count,
            "my_role": my_role
        })

    return result
```

#### 1-3. 룸에 멤버 초대

```python
POST /api/rooms/{room_id}/invite

Request:
{
  "invitee_email": "friend@example.com"
}

Response:
{
  "message": "friend@example.com 초대 완료"
}
```

**구현 코드:**

```python
@router.post("/rooms/{room_id}/invite")
def invite_to_room(
    room_id: int,
    invitee_email: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """이메일로 사용자 초대 (owner/admin만 가능)"""

    # 1. 초대자가 owner/admin인지 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id,
        RoomMember.role.in_(["owner", "admin"])
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="초대 권한이 없습니다")

    # 2. 초대할 사용자 찾기
    invitee = db.query(User).filter(User.email == invitee_email).first()
    if not invitee:
        raise HTTPException(status_code=404, detail="사용자를 찾을 수 없습니다")

    # 3. 이미 멤버인지 확인
    existing = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == invitee.id
    ).first()

    if existing:
        raise HTTPException(status_code=400, detail="이미 룸 멤버입니다")

    # 4. 멤버 추가
    new_member = RoomMember(
        room_id=room_id,
        user_id=invitee.id,
        role="member"
    )
    db.add(new_member)
    db.commit()

    return {"message": f"{invitee_email} 초대 완료"}
```

#### 1-4. 룸 멤버 목록 조회

```python
GET /api/rooms/{room_id}/members

Response:
[
  {
    "user_id": 1,
    "username": "user1",
    "email": "user1@example.com",
    "role": "owner",
    "joined_at": "2025-10-19T10:00:00"
  }
]
```

**구현 코드:**

```python
@router.get("/rooms/{room_id}/members")
def get_room_members(
    room_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """룸 멤버 목록 조회"""

    # 멤버인지 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="룸 멤버가 아닙니다")

    # 멤버 목록 조회
    members = db.query(RoomMember, User).join(User).filter(
        RoomMember.room_id == room_id
    ).all()

    result = []
    for member, user in members:
        result.append({
            "user_id": user.id,
            "username": user.username,
            "email": user.email,
            "role": member.role,
            "joined_at": member.joined_at
        })

    return result
```

---

### 2. 룸 일정 API

**파일 위치:** `Fast_api/api/room.py` (계속)

#### 2-1. 룸에 일정 등록 (자연어 파싱)

```python
POST /api/rooms/{room_id}/schedules/parse-and-create

Request:
{
  "text": "내일 오후 3시 팀 회의, 금요일 오전 10시 코드리뷰"
}

Response:
[
  {
    "id": 101,
    "title": "팀 회의",
    "scheduled_at": "2025-10-20T15:00:00",
    "user_id": 1,
    "room_id": 1
  },
  {
    "id": 102,
    "title": "코드리뷰",
    "scheduled_at": "2025-10-22T10:00:00",
    "user_id": 1,
    "room_id": 1
  }
]
```

**구현 코드:**

```python
from Fast_api.services.llm_schedule_parser import parse_natural_language_to_schedules
from Fast_api.schemas.schedule import NaturalLanguageInput, ScheduleResponse
from typing import List
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/rooms/{room_id}/schedules/parse-and-create", response_model=List[ScheduleResponse])
@limiter.limit("20/minute")
async def create_room_schedule_with_nlp(
    request: Request,
    room_id: int,
    input_data: NaturalLanguageInput,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """룸에 일정 등록 (자연어 파싱) - 모든 멤버 가능"""

    # 1. 룸 멤버인지 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="룸 멤버가 아닙니다")

    # 2. 기존 파서 재활용! 🎉
    try:
        parsed_schedules = await parse_natural_language_to_schedules(input_data.text)
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"LLM 파싱 실패: room_id={room_id}, user={current_user.username}, error={str(e)}")
        raise HTTPException(status_code=500, detail="일정 파싱 중 오류가 발생했습니다")

    # 3. 룸 일정으로 생성
    created_schedules = []
    for schedule in parsed_schedules:
        db_schedule = Schedule(
            title=schedule.title,
            description=schedule.description,
            scheduled_at=schedule.scheduled_at,
            user_id=current_user.id,  # 생성자
            room_id=room_id  # ⭐ 룸 ID 추가
        )
        db.add(db_schedule)
        db.flush()
        created_schedules.append(db_schedule)

    db.commit()
    return created_schedules
```

#### 2-2. 룸 일정 조회

```python
GET /api/rooms/{room_id}/schedules

Response:
[
  {
    "id": 101,
    "title": "팀 회의",
    "description": null,
    "scheduled_at": "2025-10-20T15:00:00",
    "is_completed": false,
    "user_id": 1,
    "room_id": 1,
    "created_by_username": "user1"
  }
]
```

**구현 코드:**

```python
@router.get("/rooms/{room_id}/schedules")
def get_room_schedules(
    room_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """룸의 모든 일정 조회"""

    # 멤버인지 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="룸 멤버가 아닙니다")

    # 일정 조회 (생성자 정보 포함)
    schedules = db.query(Schedule, User).join(User).filter(
        Schedule.room_id == room_id
    ).order_by(Schedule.scheduled_at).all()

    result = []
    for schedule, user in schedules:
        result.append({
            **schedule.__dict__,
            "created_by_username": user.username
        })

    return result
```

#### 2-3. 룸 일정 수정

```python
PUT /api/rooms/{room_id}/schedules/{schedule_id}

Request:
{
  "title": "팀 회의 (수정)",
  "scheduled_at": "2025-10-20T16:00:00"
}

Response:
{
  "id": 101,
  "title": "팀 회의 (수정)",
  "scheduled_at": "2025-10-20T16:00:00",
  ...
}
```

**구현 코드:**

```python
from Fast_api.schemas.schedule import ScheduleUpdate

@router.put("/rooms/{room_id}/schedules/{schedule_id}")
def update_room_schedule(
    room_id: int,
    schedule_id: int,
    schedule_update: ScheduleUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """룸 일정 수정 (생성자만 가능)"""

    # 일정 조회
    schedule = db.query(Schedule).filter(
        Schedule.id == schedule_id,
        Schedule.room_id == room_id
    ).first()

    if not schedule:
        raise HTTPException(status_code=404, detail="일정을 찾을 수 없습니다")

    # 생성자인지 확인
    if schedule.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="수정 권한이 없습니다")

    # 수정
    if schedule_update.title:
        schedule.title = schedule_update.title
    if schedule_update.description is not None:
        schedule.description = schedule_update.description
    if schedule_update.scheduled_at:
        schedule.scheduled_at = schedule_update.scheduled_at
    if schedule_update.is_completed is not None:
        schedule.is_completed = schedule_update.is_completed

    db.commit()
    db.refresh(schedule)
    return schedule
```

#### 2-4. 룸 일정 삭제

```python
DELETE /api/rooms/{room_id}/schedules/{schedule_id}

Response:
{
  "message": "일정이 삭제되었습니다"
}
```

**구현 코드:**

```python
@router.delete("/rooms/{room_id}/schedules/{schedule_id}")
def delete_room_schedule(
    room_id: int,
    schedule_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """룸 일정 삭제 (생성자만 가능)"""

    schedule = db.query(Schedule).filter(
        Schedule.id == schedule_id,
        Schedule.room_id == room_id
    ).first()

    if not schedule:
        raise HTTPException(status_code=404, detail="일정을 찾을 수 없습니다")

    # 생성자인지 확인
    if schedule.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="삭제 권한이 없습니다")

    db.delete(schedule)
    db.commit()

    return {"message": "일정이 삭제되었습니다"}
```

---

### 3. 공지 API

**파일 위치:** `Fast_api/api/room.py` (계속)

#### 3-1. 공지 작성

```python
POST /api/rooms/{room_id}/notices

Request:
{
  "title": "주간 회의 일정 변경",
  "content": "이번 주 회의는 금요일 오후 3시로 변경되었습니다."
}

Response:
{
  "id": 1,
  "room_id": 1,
  "user_id": 1,
  "title": "주간 회의 일정 변경",
  "content": "이번 주 회의는 금요일 오후 3시로 변경되었습니다.",
  "is_pinned": false,
  "created_at": "2025-10-19T10:00:00"
}
```

**구현 코드:**

```python
from Fast_api.models.notice import Notice

@router.post("/rooms/{room_id}/notices")
def create_notice(
    room_id: int,
    title: str,
    content: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """공지 작성 - 모든 멤버 가능"""

    # 멤버인지만 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="룸 멤버만 공지를 작성할 수 있습니다")

    notice = Notice(
        room_id=room_id,
        user_id=current_user.id,
        title=title,
        content=content
    )
    db.add(notice)
    db.commit()
    db.refresh(notice)

    return notice
```

#### 3-2. 공지 목록 조회

```python
GET /api/rooms/{room_id}/notices

Response:
[
  {
    "id": 1,
    "title": "주간 회의 일정 변경",
    "content": "...",
    "is_pinned": true,
    "user_id": 1,
    "created_by_username": "user1",
    "created_at": "2025-10-19T10:00:00"
  }
]
```

**구현 코드:**

```python
@router.get("/rooms/{room_id}/notices")
def get_notices(
    room_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """공지 목록 조회 (고정 공지 먼저, 그 다음 최신순)"""

    # 멤버 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="룸 멤버가 아닙니다")

    # 공지 조회 (작성자 정보 포함)
    notices = db.query(Notice, User).join(User).filter(
        Notice.room_id == room_id
    ).order_by(
        Notice.is_pinned.desc(),  # 고정 공지 먼저
        Notice.created_at.desc()  # 최신순
    ).all()

    result = []
    for notice, user in notices:
        result.append({
            **notice.__dict__,
            "created_by_username": user.username
        })

    return result
```

#### 3-3. 공지 고정/해제

```python
PATCH /api/rooms/{room_id}/notices/{notice_id}/pin

Response:
{
  "id": 1,
  "is_pinned": true,
  "message": "공지가 상단에 고정되었습니다"
}
```

**구현 코드:**

```python
@router.patch("/rooms/{room_id}/notices/{notice_id}/pin")
def toggle_pin_notice(
    room_id: int,
    notice_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """공지 상단 고정/해제 - owner/admin만 가능"""

    # 권한 확인
    member = db.query(RoomMember).filter(
        RoomMember.room_id == room_id,
        RoomMember.user_id == current_user.id,
        RoomMember.role.in_(["owner", "admin"])
    ).first()

    if not member:
        raise HTTPException(status_code=403, detail="고정 권한이 없습니다 (owner/admin만 가능)")

    notice = db.query(Notice).filter(
        Notice.id == notice_id,
        Notice.room_id == room_id
    ).first()

    if not notice:
        raise HTTPException(status_code=404, detail="공지를 찾을 수 없습니다")

    notice.is_pinned = not notice.is_pinned
    db.commit()
    db.refresh(notice)

    message = "공지가 상단에 고정되었습니다" if notice.is_pinned else "공지 고정이 해제되었습니다"

    return {
        "id": notice.id,
        "is_pinned": notice.is_pinned,
        "message": message
    }
```

#### 3-4. 공지 삭제

```python
DELETE /api/rooms/{room_id}/notices/{notice_id}

Response:
{
  "message": "공지가 삭제되었습니다"
}
```

**구현 코드:**

```python
@router.delete("/rooms/{room_id}/notices/{notice_id}")
def delete_notice(
    room_id: int,
    notice_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """공지 삭제 (작성자만 가능)"""

    notice = db.query(Notice).filter(
        Notice.id == notice_id,
        Notice.room_id == room_id
    ).first()

    if not notice:
        raise HTTPException(status_code=404, detail="공지를 찾을 수 없습니다")

    # 작성자인지 확인
    if notice.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="삭제 권한이 없습니다")

    db.delete(notice)
    db.commit()

    return {"message": "공지가 삭제되었습니다"}
```

---

## 프론트엔드 컴포넌트

### 1. RoomList (룸 목록)

**파일 위치:** `react_ui/src/components/RoomList.js`

```jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

const API_URL = process.env.REACT_APP_API_BASE_URL || '';

function RoomList() {
  const [rooms, setRooms] = useState([]);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [roomName, setRoomName] = useState('');
  const [roomDescription, setRoomDescription] = useState('');
  const navigate = useNavigate();
  const token = localStorage.getItem('token');

  // 룸 목록 불러오기
  useEffect(() => {
    fetch(`${API_URL}/api/rooms`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    })
    .then(res => res.json())
    .then(setRooms)
    .catch(err => console.error(err));
  }, [token]);

  // 룸 생성
  const handleCreateRoom = async () => {
    const response = await fetch(`${API_URL}/api/rooms`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        name: roomName,
        description: roomDescription
      })
    });

    if (response.ok) {
      const newRoom = await response.json();
      setRooms([...rooms, newRoom]);
      setRoomName('');
      setRoomDescription('');
      setShowCreateModal(false);
    }
  };

  return (
    <div className="room-list">
      <h2>공유 일정 방</h2>

      <div className="rooms">
        {rooms.map(room => (
          <div
            key={room.id}
            className="room-card"
            onClick={() => navigate(`/rooms/${room.id}`)}
          >
            <h3>{room.name}</h3>
            <p>{room.description}</p>
            <div className="room-info">
              <span>멤버 {room.member_count}명</span>
              <span className="role">{room.my_role}</span>
            </div>
          </div>
        ))}
      </div>

      <button
        className="create-room-btn"
        onClick={() => setShowCreateModal(true)}
      >
        + 새 방 만들기
      </button>

      {showCreateModal && (
        <div className="modal">
          <div className="modal-content">
            <h3>새 방 만들기</h3>
            <input
              type="text"
              placeholder="방 이름"
              value={roomName}
              onChange={(e) => setRoomName(e.target.value)}
            />
            <textarea
              placeholder="설명 (선택)"
              value={roomDescription}
              onChange={(e) => setRoomDescription(e.target.value)}
            />
            <div className="modal-buttons">
              <button onClick={handleCreateRoom}>생성</button>
              <button onClick={() => setShowCreateModal(false)}>취소</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default RoomList;
```

---

### 2. RoomSchedulePage (룸 일정)

**파일 위치:** `react_ui/src/components/RoomSchedulePage.js`

```jsx
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';

const API_URL = process.env.REACT_APP_API_BASE_URL || '';

function RoomSchedulePage() {
  const { roomId } = useParams();
  const [schedules, setSchedules] = useState([]);
  const [naturalInput, setNaturalInput] = useState('');
  const [roomInfo, setRoomInfo] = useState(null);
  const token = localStorage.getItem('token');

  // 룸 정보 및 일정 불러오기
  useEffect(() => {
    // 룸 정보
    fetch(`${API_URL}/api/rooms/${roomId}`, {
      headers: { 'Authorization': `Bearer ${token}` }
    })
    .then(res => res.json())
    .then(setRoomInfo);

    // 룸 일정
    fetch(`${API_URL}/api/rooms/${roomId}/schedules`, {
      headers: { 'Authorization': `Bearer ${token}` }
    })
    .then(res => res.json())
    .then(setSchedules);
  }, [roomId, token]);

  // 자연어로 일정 추가
  const handleAddSchedule = async () => {
    if (!naturalInput.trim()) return;

    const response = await fetch(
      `${API_URL}/api/rooms/${roomId}/schedules/parse-and-create`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ text: naturalInput })
      }
    );

    if (response.ok) {
      const newSchedules = await response.json();
      setSchedules([...schedules, ...newSchedules]);
      setNaturalInput('');
    } else {
      const error = await response.json();
      alert(error.detail || '일정 추가 실패');
    }
  };

  return (
    <div className="room-schedule-page">
      <h2>{roomInfo?.name || '공유 일정'}</h2>
      <p>{roomInfo?.description}</p>

      {/* 자연어 입력 (개인 일정과 동일한 UI!) */}
      <div className="schedule-input">
        <textarea
          value={naturalInput}
          onChange={(e) => setNaturalInput(e.target.value)}
          placeholder="예: 내일 오후 3시 팀 회의, 금요일 오전 10시 코드리뷰"
          rows="3"
        />
        <button onClick={handleAddSchedule}>일정 추가</button>
      </div>

      {/* 일정 목록 */}
      <div className="schedules">
        <h3>일정 목록</h3>
        {schedules.length === 0 && <p>아직 일정이 없습니다.</p>}
        {schedules.map(schedule => (
          <div key={schedule.id} className="schedule-card">
            <h4>{schedule.title}</h4>
            {schedule.description && <p>{schedule.description}</p>}
            <div className="schedule-meta">
              <span>{new Date(schedule.scheduled_at).toLocaleString('ko-KR')}</span>
              <span className="creator">작성: {schedule.created_by_username}</span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default RoomSchedulePage;
```

---

### 3. RoomNoticePage (룸 공지)

**파일 위치:** `react_ui/src/components/RoomNoticePage.js`

```jsx
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';

const API_URL = process.env.REACT_APP_API_BASE_URL || '';

function RoomNoticePage() {
  const { roomId } = useParams();
  const [notices, setNotices] = useState([]);
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const token = localStorage.getItem('token');

  // 공지 목록 불러오기
  useEffect(() => {
    fetch(`${API_URL}/api/rooms/${roomId}/notices`, {
      headers: { 'Authorization': `Bearer ${token}` }
    })
    .then(res => res.json())
    .then(setNotices);
  }, [roomId, token]);

  // 공지 작성
  const handleCreateNotice = async () => {
    if (!title.trim() || !content.trim()) {
      alert('제목과 내용을 입력해주세요');
      return;
    }

    const response = await fetch(`${API_URL}/api/rooms/${roomId}/notices`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ title, content })
    });

    if (response.ok) {
      const newNotice = await response.json();
      setNotices([newNotice, ...notices]);
      setTitle('');
      setContent('');
    }
  };

  return (
    <div className="notice-page">
      <h2>공지사항</h2>

      {/* 공지 작성 폼 (모든 멤버에게 표시) */}
      <div className="notice-form">
        <h3>공지 작성</h3>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="제목"
        />
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="내용"
          rows="5"
        />
        <button onClick={handleCreateNotice}>공지 등록</button>
      </div>

      {/* 공지 목록 */}
      <div className="notices">
        <h3>공지 목록</h3>
        {notices.length === 0 && <p>아직 공지가 없습니다.</p>}
        {notices.map(notice => (
          <div
            key={notice.id}
            className={`notice-card ${notice.is_pinned ? 'pinned' : ''}`}
          >
            {notice.is_pinned && <span className="pin-icon">📌</span>}
            <h4>{notice.title}</h4>
            <p className="notice-content">{notice.content}</p>
            <div className="notice-meta">
              <span className="author">작성: {notice.created_by_username}</span>
              <span className="date">
                {new Date(notice.created_at).toLocaleString('ko-KR')}
              </span>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default RoomNoticePage;
```

---

### 4. 라우팅 추가

**파일 위치:** `react_ui/src/App.js` (수정)

```jsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import LoginForm from './components/LoginForm';
import SignupForm from './components/SignupForm';
import SchedulePage from './components/SchedulePage';
import RoomList from './components/RoomList';
import RoomSchedulePage from './components/RoomSchedulePage';
import RoomNoticePage from './components/RoomNoticePage';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<LoginForm />} />
        <Route path="/signup" element={<SignupForm />} />
        <Route path="/schedules" element={<SchedulePage />} />

        {/* 룸 관련 라우트 (신규) */}
        <Route path="/rooms" element={<RoomList />} />
        <Route path="/rooms/:roomId" element={<RoomSchedulePage />} />
        <Route path="/rooms/:roomId/notices" element={<RoomNoticePage />} />
      </Routes>
    </Router>
  );
}

export default App;
```

---

## 권한 설계

### 룸 멤버 역할

| 역할 | 설명 | 권한 |
|------|------|------|
| **owner** | 룸 생성자 | 모든 권한 (멤버 초대/강퇴, 공지 고정, 룸 삭제) |
| **admin** | 관리자 | 멤버 초대, 공지 고정 |
| **member** | 일반 멤버 | 일정 등록, 공지 작성, 본인 일정 수정/삭제 |

### 권한 매트릭스

| 기능 | owner | admin | member |
|------|-------|-------|--------|
| 룸 생성 | ✅ (자동) | - | - |
| 룸 삭제 | ✅ | ❌ | ❌ |
| 멤버 초대 | ✅ | ✅ | ❌ |
| 멤버 강퇴 | ✅ | ❌ | ❌ |
| 일정 등록 | ✅ | ✅ | ✅ |
| 일정 수정/삭제 (본인) | ✅ | ✅ | ✅ |
| 일정 수정/삭제 (타인) | ✅ (선택) | ❌ | ❌ |
| 공지 작성 | ✅ | ✅ | ✅ |
| 공지 고정/해제 | ✅ | ✅ | ❌ |
| 공지 수정/삭제 (본인) | ✅ | ✅ | ✅ |

---

## 구현 난이도 및 일정

### 난이도 평가 (5점 만점)

#### 백엔드 (FastAPI) - **난이도 2.5/5** ⭐⭐☆☆☆

| 작업 | 난이도 | 예상 시간 | 비고 |
|------|--------|----------|------|
| DB 모델 추가 (Room, RoomMember, Notice) | ⭐⭐ | 30분 | 기존 구조 참고 가능 |
| 룸 API (생성/조회/초대) | ⭐⭐☆ | 1시간 | 권한 체크 로직 필요 |
| 룸 일정 API (파서 재활용) | ⭐☆ | 30분 | 기존 코드 재사용 |
| 공지 API (CRUD) | ⭐⭐ | 40분 | 일정 API와 유사 |
| Alembic 마이그레이션 | ⭐ | 10분 | 자동 생성 |

**총 예상 시간: 2.5~3시간**

#### 프론트엔드 (React) - **난이도 2/5** ⭐⭐☆☆☆

| 작업 | 난이도 | 예상 시간 | 비고 |
|------|--------|----------|------|
| RoomList 컴포넌트 | ⭐⭐ | 40분 | 기본 목록 UI |
| RoomSchedulePage | ⭐☆ | 30분 | SchedulePage 복사 + 수정 |
| RoomNoticePage | ⭐⭐ | 50분 | 간단한 게시판 형태 |
| 멤버 초대 모달 | ⭐⭐ | 40분 | 이메일 입력 폼 |
| 라우팅 추가 | ⭐ | 10분 | react-router 경로 추가 |
| CSS 스타일링 | ⭐⭐ | 30분 | 기본 스타일 적용 |

**총 예상 시간: 2.5~3시간**

### 전체 일정

**총 작업 시간: 5~7시간** (1~2일)

- ✅ 기존 구조가 잘 되어 있어 빠름
- ✅ 파서 재활용으로 시간 절약
- ⚠️ 처음 구현 시 디버깅 시간 추가 (+ 2~3시간)

**추천 일정:**
- Day 1: 백엔드 구현 (3시간)
- Day 2: 프론트엔드 구현 (3시간)
- Day 3: 테스트 & 버그 수정 (1~2시간)

---

## 구현 순서

### Phase 1: 백엔드 기본 구조 (1~1.5시간)

#### 1-1. DB 모델 생성

```bash
# 새 파일 생성
touch Fast_api/models/room.py
touch Fast_api/models/notice.py
```

**작업 내용:**
- `Fast_api/models/room.py`: Room, RoomMember 모델 정의
- `Fast_api/models/notice.py`: Notice 모델 정의
- `Fast_api/models/schedule.py`: room_id 컬럼 추가

#### 1-2. Alembic 마이그레이션

```bash
# 마이그레이션 파일 자동 생성
alembic revision --autogenerate -m "Add room and notice tables"

# 마이그레이션 실행
alembic upgrade head
```

#### 1-3. 기본 API 라우터 생성

```bash
touch Fast_api/api/room.py
```

**작업 내용:**
- 룸 생성 API
- 룸 목록 조회 API
- `Fast_api/main.py`에 라우터 등록

```python
# Fast_api/main.py (수정)
from Fast_api.api import room

app.include_router(room.router, prefix="/api", tags=["rooms"])
```

---

### Phase 2: 백엔드 핵심 기능 (1~1.5시간)

#### 2-1. 룸 관리 API 완성

**작업 내용:**
- 멤버 초대 API
- 멤버 목록 조회 API
- 멤버 권한 확인 로직

#### 2-2. 룸 일정 API 구현

**작업 내용:**
- 자연어 파싱 일정 등록 (파서 재활용)
- 룸 일정 조회
- 룸 일정 수정/삭제
- rate limiting 적용

#### 2-3. 공지 API 구현

**작업 내용:**
- 공지 CRUD API
- 공지 고정/해제 API
- 권한 체크 로직

---

### Phase 3: 프론트엔드 기본 (1~1.5시간)

#### 3-1. 컴포넌트 파일 생성

```bash
touch react_ui/src/components/RoomList.js
touch react_ui/src/components/RoomSchedulePage.js
touch react_ui/src/components/RoomNoticePage.js
```

#### 3-2. RoomList 구현

**작업 내용:**
- 룸 목록 표시
- 룸 생성 모달
- 룸 클릭 시 상세 페이지 이동

#### 3-3. 라우팅 추가

**작업 내용:**
- `react_ui/src/App.js`에 라우트 추가
- 네비게이션 메뉴에 "공유 일정" 링크 추가

---

### Phase 4: 프론트엔드 추가 기능 (1~1.5시간)

#### 4-1. RoomSchedulePage 구현

**작업 내용:**
- 자연어 입력 폼 (기존 SchedulePage 참고)
- 일정 목록 표시
- 작성자 표시

#### 4-2. RoomNoticePage 구현

**작업 내용:**
- 공지 작성 폼
- 공지 목록 표시
- 고정 공지 시각적 구분

#### 4-3. 멤버 초대 UI

**작업 내용:**
- 이메일 입력 모달
- 멤버 목록 표시

---

### Phase 5: 스타일링 및 테스트 (1~2시간)

#### 5-1. CSS 스타일링

**작업 내용:**
- 룸 카드 디자인
- 공지 고정 스타일 (📌 아이콘)
- 반응형 레이아웃

#### 5-2. 테스트

**작업 내용:**
- 룸 생성/초대 테스트
- 일정 등록 테스트 (자연어)
- 공지 작성/고정 테스트
- 권한 체크 테스트
- 에러 처리 확인

---

## 개선 방향 (향후)

### Short-term (1~2주 내)

1. **알림 기능 추가**
   - 이메일 알림 (일정 30분 전)
   - 멤버 초대 알림
   - 공지 작성 알림

2. **UI/UX 개선**
   - 룸별 색상 테마
   - 드래그 앤 드롭으로 일정 이동
   - 캘린더 뷰 (통합)

3. **검색 기능**
   - 룸 이름으로 검색
   - 일정 제목/내용 검색

### Mid-term (1~2개월 내)

1. **실시간 동기화**
   - WebSocket으로 실시간 업데이트
   - 누가 일정을 추가했는지 실시간 표시

2. **파일 첨부**
   - 공지에 파일 첨부 기능
   - 일정에 파일 첨부 (회의록 등)

3. **통계 대시보드**
   - 룸별 일정 통계
   - 참여율 분석
   - 가장 활발한 멤버

### Long-term (3개월 이상)

1. **외부 캘린더 연동**
   - Google Calendar 연동
   - Outlook 연동

2. **모바일 앱**
   - React Native로 모바일 앱 개발
   - 푸시 알림

3. **AI 기능 강화**
   - 일정 추천 (과거 패턴 분석)
   - 자동 카테고리 분류
   - 회의 시간 최적화 제안

---

## 주의사항

### 보안

1. **권한 체크 필수**
   - 모든 API에서 룸 멤버 여부 확인
   - owner/admin 전용 기능은 role 체크

2. **SQL Injection 방어**
   - ORM 사용 (이미 적용 중)
   - 사용자 입력 검증

3. **Rate Limiting**
   - 일정 등록 API에 rate limit 적용 (이미 있음)
   - 공지 작성도 동일하게 적용 권장

### 성능

1. **N+1 쿼리 방지**
   - JOIN 사용으로 한 번에 조회
   - 예: 일정 조회 시 작성자 정보도 함께

2. **페이지네이션**
   - 일정/공지가 많아지면 페이지네이션 추가
   - 현재는 `limit` 파라미터로 제한

3. **캐싱**
   - 룸 멤버 정보는 자주 변경되지 않으므로 캐싱 고려

### 사용성

1. **에러 메시지**
   - 사용자 친화적인 메시지
   - 상태 코드 명확히 구분

2. **로딩 상태**
   - API 호출 중 로딩 표시
   - 사용자 경험 개선

3. **입력 검증**
   - 프론트엔드에서 기본 검증
   - 백엔드에서 최종 검증

---

## 참고 자료

### 기존 코드 참고

- **일정 파서**: `Fast_api/services/llm_schedule_parser.py`
- **일정 API**: `Fast_api/api/schedule.py`
- **일정 컴포넌트**: `react_ui/src/components/SchedulePage.js`

### 외부 라이브러리

- **Alembic**: DB 마이그레이션
- **SQLAlchemy**: ORM
- **FastAPI**: 백엔드 프레임워크
- **React Router**: 프론트엔드 라우팅

---

## 마무리

이 계획서는 **채팅방 컨셉의 공유 일정 기능**을 추가하기 위한 전체 로드맵입니다.

### 핵심 포인트

✅ **기존 코드 재활용**: 자연어 파서 그대로 사용
✅ **깔끔한 분리**: 개인 일정과 공유 일정 독립적
✅ **간단한 권한 관리**: owner/admin/member 3단계
✅ **실용적인 기능**: 일정 + 공지만으로 충분히 유용

**예상 작업 시간: 5~7시간 (1~2일)**

천천히 단계별로 구현하면서, 각 단계마다 테스트하면 안정적으로 완성할 수 있습니다!

화이팅! 🚀
